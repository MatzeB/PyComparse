#!/usr/bin/env python3
"""Generate unicode_xid_table.c/.h — a 2-stage lookup table for XID_Start/XID_Continue.

Run with: uv run scripts/gen_xid_table.py

Uses Python 3.8's str.isidentifier() which reflects Unicode 12.1.0,
matching exactly what CPython 3.8 considers valid identifiers.

Encoding: 2 bits per codepoint
  0 = neither XID_Start nor XID_Continue
  2 = XID_Continue only (e.g. combining marks, digits)
  3 = both XID_Start and XID_Continue
  (value 1 never occurs — XID_Start is a subset of XID_Continue)
"""

import sys

SHIFT = 7  # 128 codepoints per block
BLOCK_SIZE = 1 << SHIFT  # 128
MAX_CP = 0x110000  # exclusive


def classify(cp):
    """Return 0, 2, or 3 for a codepoint."""
    c = chr(cp)
    # XID_Start: can start an identifier (but not be a keyword by itself)
    # We test by checking if the single char is a valid identifier.
    # str.isidentifier() returns True for XID_Start characters.
    is_start = c.isidentifier()
    # XID_Continue: can continue an identifier.
    # We test by prepending an underscore.
    is_continue = ("_" + c).isidentifier()
    if is_start and is_continue:
        return 3
    elif is_continue:
        return 2
    else:
        return 0


def pack_block(values):
    """Pack 128 2-bit values into 32 bytes (4 per byte)."""
    assert len(values) == BLOCK_SIZE
    packed = []
    for i in range(0, BLOCK_SIZE, 4):
        byte = (
            values[i]
            | (values[i + 1] << 2)
            | (values[i + 2] << 4)
            | (values[i + 3] << 6)
        )
        packed.append(byte)
    return bytes(packed)


def generate():
    # Classify all codepoints
    data = [0] * MAX_CP
    for cp in range(MAX_CP):
        try:
            data[cp] = classify(cp)
        except (ValueError, OverflowError):
            data[cp] = 0

    # Only care about codepoints >= 128 for this table (ASCII handled separately)
    # But we include 0-127 for completeness (they'll just never be looked up).
    num_blocks = MAX_CP >> SHIFT
    blocks = []
    for i in range(num_blocks):
        start = i * BLOCK_SIZE
        block = data[start : start + BLOCK_SIZE]
        blocks.append(pack_block(block))

    # Deduplicate blocks
    unique_blocks = []
    block_to_index = {}
    index1 = []
    for block in blocks:
        if block not in block_to_index:
            block_to_index[block] = len(unique_blocks)
            unique_blocks.append(block)
        index1.append(block_to_index[block])

    num_unique = len(unique_blocks)
    bytes_per_block = BLOCK_SIZE // 4  # 32 bytes
    total_bytes = num_unique * bytes_per_block

    # Print stats to stderr
    print(
        (
            f"Blocks: {num_blocks} total, {num_unique} unique\n"
            f"index1: {len(index1)} bytes\n"
            f"index2: {total_bytes} bytes\n"
            f"Total:  {len(index1) + total_bytes} bytes"
        ),
        file=sys.stderr,
    )
    assert num_unique <= 256, f"Too many unique blocks ({num_unique}), need uint16_t"

    # Generate .c file (data tables)
    with open("unicode_xid_table.c", "w") as f:
        f.write(
            """\
/* Generated by scripts/gen_xid_table.py — do not edit. */

#include "unicode_xid_table.h"
"""
        )
        f.write(f"const uint8_t xid_index1[{len(index1)}] = {{\n")
        for i in range(0, len(index1), 16):
            chunk = index1[i : i + 16]
            f.write("  " + ", ".join(f"{v:3d}" for v in chunk) + ",\n")
        f.write("};\n\n")
        f.write(f"const uint8_t xid_index2[{total_bytes}] = {{\n")
        for bi, block in enumerate(unique_blocks):
            f.write(f"  /* block {bi} */\n")
            for i in range(0, len(block), 16):
                chunk = block[i : i + 16]
                f.write("  " + ", ".join(f"0x{b:02x}" for b in chunk) + ",\n")
        f.write("};\n")

    # Generate .h file (declarations + inline lookup functions)
    with open("unicode_xid_table.h", "w") as f:
        f.write(
            """\
/* Generated by scripts/gen_xid_table.py — do not edit. */
/* Unicode XID_Start / XID_Continue lookup table (Unicode 12.1.0) */

#pragma once

#include <stdint.h>
"""
        )
        f.write(
            f"""\
#define XID_SHIFT {SHIFT}
#define XID_BLOCK_MASK {hex(BLOCK_SIZE - 1)}

extern const uint8_t xid_index1[{len(index1)}];
extern const uint8_t xid_index2[{total_bytes}];

static inline int is_xid_continue(uint32_t cp)
{{
  if (cp >= 0x{MAX_CP:x}) return 0;
  uint32_t block = xid_index1[cp >> XID_SHIFT];
  uint32_t offset = cp & XID_BLOCK_MASK;
  uint8_t packed = xid_index2[block * {bytes_per_block} + (offset >> 2)];
  return (packed >> ((offset & 3) * 2)) & 2;
}}

static inline int is_xid_start(uint32_t cp)
{{
  if (cp >= 0x{MAX_CP:x}) return 0;
  uint32_t block = xid_index1[cp >> XID_SHIFT];
  uint32_t offset = cp & XID_BLOCK_MASK;
  uint8_t packed = xid_index2[block * {bytes_per_block} + (offset >> 2)];
  return (packed >> ((offset & 3) * 2)) & 1;
}}
"""
        )


if __name__ == "__main__":
    generate()
